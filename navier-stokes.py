#!/usr/bin/env python
# coding: utf-8

"""
FEniCS tutorial demo program: Incompressible Navier-Stokes equations
for channel flow on the unit square using the
Incremental Pressure Correction Scheme (IPCS).

  u' + u . nabla(u)) - div(sigma(u, p)) = f
								 div(u) = 0
"""

from __future__ import print_function
from datetime import datetime
from fenics import *
from mshr import *
import numpy as np
import matplotlib.pyplot as plt
import sys, getopt, argparse

def parse_commandline_args():
	global args
	
	# From https://stackoverflow.com/questions/53937481/python-command-line-arguments-foo-and-no-foo
	def add_bool_arg(parser, name, default=False, dest=None, help=None):
		if(dest is None):
			dest = name
		
		group = parser.add_mutually_exclusive_group(required=False)
		group.add_argument('--' + name, dest=dest, action='store_true', help=help)
		group.add_argument('--no-' + name, dest=dest, action='store_false', help=help)
		parser.set_defaults(**{name:default})
	
	# See https://docs.python.org/2/library/argparse.html
	parser = argparse.ArgumentParser()
	parser.add_argument('--final-time', default=10.0, type=float, dest='final_time', help='How long to run the simulation for (default: %(default)s)')
	parser.add_argument('--steps-n', default=10, type=int, dest='steps_n', help='How many steps each of the "seconds" is made of (default: %(default)s)')
	parser.add_argument('--viscosity', default=100, type=int, help='Viscosity (default: %(default)s)')
	parser.add_argument('--density', default=1, type=int, help='Density (default: %(default)s)')
	parser.add_argument('--domain', default='custom', help='What domain to use, either `square` or `custom` (default: %(default)s)')
	parser.add_argument('--mesh-resolution', default=16, type=int, dest='mesh_resolution', help='Mesh resolution (default: %(default)s)')
	parser.add_argument('-v', '--verbose', default=False, dest='verbose', action='store_true', help='Whether to dsplay debug info (default: %(default)s)')
	add_bool_arg(parser, 'plot', default=True, help='Whether to plot solution (default: %(default)s)')
	add_bool_arg(parser, 'plot-BC', default=False, dest='plot_BC', help='Wheher to plot boundary conditions (default: %(default)s)')
	args = parser.parse_args()

def define_variational_problems():
	global A1, A2, A3, L1, L2, L3
	global rho, mu
	
	# Define trial and test functions
	u = TrialFunction(V)
	v = TestFunction(V)
	p = TrialFunction(Q)
	q = TestFunction(Q)
	
	# Define expressions used in variational forms
	U   = 0.5*(u_n + u)
	n   = FacetNormal(mesh)
	g   = 9.81
	f   = Constant((0, -g))
	k   = Constant(dt)
	mu  = Constant(mu)
	rho = Constant(rho)
	
	# Define strain-rate tensor
	def epsilon(u):
		return sym(nabla_grad(u))

	# Define stress tensor
	def sigma(u, p):
		return 2*mu*epsilon(u) - p*Identity(len(u))

	# Define variational problem for step 1
	F1 = rho*dot((u - u_n) / k, v)*dx +      rho*dot(dot(u_n, nabla_grad(u_n)), v)*dx      + inner(sigma(U, p_n), epsilon(v))*dx      + dot(p_n*n, v)*ds - dot(mu*nabla_grad(U)*n, v)*ds      - dot(f, v)*dx
	a1 = lhs(F1)
	L1 = rhs(F1)

	# Define variational problem for step 2
	a2 = dot(nabla_grad(p), nabla_grad(q))*dx
	L2 = dot(nabla_grad(p_n), nabla_grad(q))*dx - (1/k)*div(u_)*q*dx

	# Define variational problem for step 3
	a3 = dot(u, v)*dx
	L3 = dot(u_, v)*dx - k*dot(nabla_grad(p_ - p_n), v)*dx
	
	# Assemble matrices
	A1 = assemble(a1)
	A2 = assemble(a2)
	A3 = assemble(a3)

def deform_mesh_coords(mesh):
	x = mesh.coordinates()[:, 0]
	y = mesh.coordinates()[:, 1]
	
	new_y = [y[i] + 0.1*np.sin(3*pi*(x[i]-(3/8)))*(1-y[i]) if(x[i] < 0.75 and x[i] > 0.3) else 0 for i in range(len(y)) ]
	y = np.maximum(y, new_y)

	mesh.coordinates()[:] = np.array([x, y]).transpose()

def initialize_mesh( domain, resolution ):
	""" To create a Mesh, either use one of the built-in meshes https://fenicsproject.org/docs/dolfin/1.4.0/python/demo/documented/built-in_meshes/python/documentation.html or create a custom one. 
	
	Notice that the class PolygonalMeshGenerator has been deprecated so it's no longer available. Instead, we need to call generate_mesh on a custom domain. Custom domains are generated by combining through union, intersection or difference elementary shapes. Custom meshes require the package mshr https://bitbucket.org/benjamik/mshr/src/master/ , which comes if FEniCS is installed system-wide (i.e. through apt, not through Anaconda). Elementary shapes are, which are dolfin.Point, Rectangle, Circle, Ellipse, Polygon: https://bitbucket.org/benjamik/mshr/wiki/browse/API
	
	The two next cells are **alternatives** implementing a built-in mesh over a unit square or custom one."""
	
	global mesh
	
	if domain == "square":
		mesh = UnitSquareMesh(resolution, resolution)
	elif domain == 'custom':
		fenics_domain = Rectangle(Point(0., 0.), Point(1., 1.)) - \
						Rectangle(Point(0.0, 0.9), Point(0.4, 1.0)) 
		mesh = generate_mesh(fenics_domain, resolution, "cgal")
		
	if domain == 'custom':
		deform_mesh_coords(mesh)

	#plot(mesh)
	
def define_function_spaces():
	global V, Q, u_n, u_, p_n, p_
	
	# Define function spaces
	V = VectorFunctionSpace(mesh, 'P', 2)
	Q = FunctionSpace(mesh, 'P', 1)

	# Define functions for solution computation
	u_n = Function(V)
	u_  = Function(V)
	p_n = Function(Q)
	p_  = Function(Q)

def boundary_conditions():
	global bcu, bcp
	
	bcu = []
	bcp = []
	
	# Define boundaries
	if(args.domain == 'square'):
		left   = 'near(x[0], 0)'
		right  = 'near(x[0], 1)'
		top    = 'near(x[1], 1)'
		bottom = 'near(x[1], 0)'
	
	elif(args.domain == 'custom'):
		left   = 'near(x[0], 0)'
		right  = 'near(x[0], 1)'
		
		def bottom(x, on_boundary):
			if(near(x[1], 0.1*np.sin(3*pi*(x[0]-(3/8)))) and on_boundary and (x[0] < 0.75 and x[0] > 0.3)):
				return True
			elif(near(x[1], 0) and on_boundary and (x[0] >= 0.75 or x[0] <= 0.3)):
				return True
			else:
				False
		
		def top(x, on_boundary):
			if((x[0] <= 0.4 and x[0] >= 0) and near(x[1], 0.9) and on_boundary):
				return True
			elif(near(x[0], 0.4) and on_boundary and (x[1] >= 0.9 and x[1] <= 1)):
				return True
			elif(x[0] > 0.4 and on_boundary and near(x[1], 1)):
				return True
			else:
				False
	
	# Define boundary conditions
	ux_sin = Expression(("-sin(2*pi*x[1])", 0), degree = 2)
	#ux_linear = Expression(('x[1]-(1/2)', 0), degree = 2)

	bcu.append(DirichletBC(V, ux_sin, right))
	bcu.append(DirichletBC(V.sub(1), Constant(0.0), bottom))
	bcu.append(DirichletBC(V.sub(1), Constant(0.0), top))
	bcu.append(DirichletBC(V.sub(0), Constant(0.0), left))
	bcu.append(DirichletBC(V.sub(1), Constant(0.0), left))
	
	bcp.append(DirichletBC(Q, Constant(0), top))
	
	# Apply boundary conditions to matrices
	[bc.apply(A1) for bc in bcu]
	[bc.apply(A2) for bc in bcp]
	
def run_simulation():
	global u_, p_
	
	# Time-stepping
	t = 0
	for n in range(num_steps*int(T)):
		t += dt

		# Step 1: Tentative velocity step
		b1 = assemble(L1)
		[bc.apply(b1) for bc in bcu]
		solve(A1, u_.vector(), b1)

		# Step 2: Pressure correction step
		b2 = assemble(L2)
		[bc.apply(b2) for bc in bcp]
		solve(A2, p_.vector(), b2)

		# Step 3: Velocity correction step
		b3 = assemble(L3)
		solve(A3, u_.vector(), b3)

		# Compute error
		#u_e = Expression(('4*x[1]*(1.0 - x[1])', '0'), degree=2)
		#u_e = interpolate(u_e, V)
		#error = np.abs(u_e.vector().get_local() - u_.vector().get_local()).max()
		#print('t = %.2f: error = %.3g' % (t, error))
		#print('max u:', u_.vector().get_local().max())

		# Update previous solution
		u_n.assign(u_)
		p_n.assign(p_)
	
	return u_, p_
		
def plot_solution():
	# Plot solution
	#fig = plt.figure(figsize=(80, 60))

	fig1 = plot(u_, title='velocity X,Y')
	plt.show()

	fig2 = plot(u_[0], title='velocity X')
	plt.colorbar(fig2)
	plt.show()

	fig3 = plot(u_[1], title='velocity Y')
	plt.colorbar(fig3)
	plt.show()

	fig = plot(p_, title='pressure')
	plt.colorbar(fig)
	plt.show()
	
def plot_boundary_conditions():
	_u_1, _u_2 = u_.split(True)

	bmesh = BoundaryMesh(mesh, "exterior", True)
	boundarycoords = bmesh.coordinates()

	rightboundary=[]
	xvelrightboundary=[]
	BC = np.empty(shape=(len(boundarycoords), 2)) #https://stackoverflow.com/a/569063
	for i in range(len(boundarycoords)):
		
		if boundarycoords[i][0]==1:
			BC[i][1] = boundarycoords[i][1]
			BC[i][0] = (_u_1(boundarycoords[i]))/10+1
		else:
			BC[i][0] = boundarycoords[i][0]
			BC[i][1] = boundarycoords[i][1]

	fig6 = plt.figure()
	plt.scatter(BC[:,0], BC[:,1])
	plt.show()

	#plt.scatter(boundarycoords[:,0], boundarycoords[:,1])

if __name__ == '__main__':
	
	print('Started at: ' + str(datetime.now()))
	
	parse_commandline_args()
	
	T = float(args.final_time)      # final time
	num_steps = int(args.steps_n)   # number of time steps per second
	dt = 1 / num_steps 				# time step size
	mu = float(args.viscosity)      # kinematic viscosity
	rho = float(args.density)       # density
	
	if(args.verbose == True):
		set_log_active(True)
		set_log_level(1)
	
	initialize_mesh( args.domain, args.mesh_resolution )
	define_function_spaces()
	define_variational_problems()
	boundary_conditions()
	run_simulation()
	
	print('Finished at: ' + str(datetime.now()))
	
	if(args.plot == True):
		plot_solution()
	
	if(args.plot_BC == True):
		plot_boundary_conditions()
		
